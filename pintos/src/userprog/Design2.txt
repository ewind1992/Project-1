+--------------------------+
|         CIS 520          |
| PROJECT 2: USER PROGRAMS |
|     DESIGN DOCUMENT      |
+--------------------------+


---- GROUP ----


>> Fill in the names of your group members.


Jim Groening
Jarrod Krebs
Kevin Schwarz


---- PRELIMINARIES ----


>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.


We are having some irregular timeout issues on different machines
when running make check.  All tests have passed multiple times on one
machine, but on other team member’s computers a few tests sometimes
timeout.


We think this could be a github problem since the tests are not
always consistent. 


>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.


www.github.com
www.gitref.org


                           ARGUMENT PASSING
                           ================


---- DATA STRUCTURES ----


>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.


process.h additions
---------------------------
// Struct for keeping track of process execution data
struct exec_info
{
  char * file_name;
  struct semaphore load_done;
  bool success;
  struct wait_info *wait_status;
};


syscall.c additions
----------------------------
struct lock fs_lock;  //lock used to control access to the file system 




---- ALGORITHMS ----


>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?


We implemented argument parsing by first tokenizing the command line
prompt and put each argument into a char array. The arguments are in 
order in the char array, but we must push them onto
the stack in reverse order so that we can later pull them off in the
correct order when next function is executed.  Overflowing the stack
page is avoided by limiting the max number of arguments.


---- RATIONALE ----


>> A3: Why does Pintos implement strtok_r() but not strtok()?


Pintos implements strtoc_r() because it is a reentrant version of
strtok() so that it can be interrupted and restarted safely.


>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.


One advantage is that users can have access to services in the kernel
without directly modifying the kernel space.


A second advantage is a smaller kernel potentially because there can
less checks that have to do with protecting itself from bad pointers.




                             SYSTEM CALLS
                             ============


---- DATA STRUCTURES ----


>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.


thread.h additions
--------------------------
struct semaphore p_done;  // Semaphore used to synchronize wait and exit in syscalls.
int next_handle;          // keep track of next value for a new handle    
struct list fd_list;     // List of file descriptors
int exit_status;         // Exit status of the thread
struct list children;    // List of children of this process hold references to wait_info of each child process
struct wait_info *wait_status; // wait status of this thread and is held in list by parent   
struct file *bin_file;  // pointer to keep track of binary file executable, enable us to close file when process exits


//structure that describes file
struct file_descriptor
{
   struct list_elem elem; // list elem to enable being put into a list
   struct file *file;    // already existing file structure in pintos
   int handle;     //handle of file, unique to this thread only
};


struct wait_info
{
  tid_t tid;
  int ref_cnt;
  int exit_code;
  struct list_elem elem;
  struct thread *holder;
};




>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?


Every open file has a file descriptor. The thread has a list of all
open files by keeping a list of file descriptors. The file descriptor
structure contains a unique handle that allows a thread to
distinguish between files.  File descriptors are not unique within
the entire OS.  A variable called next_handle is used within each
thread and initialized to 2 when the thread is initialized.
Next_handle is used when setting a file’s handle when it is opened,
then next_handle is incremented.




---- ALGORITHMS ----


>> B3: Describe your code for reading and writing user data from the
>> kernel.


We use memcopy to copy data from kernel space to the stack so that we
can use the data in user space.  The stack pointer is used in
conjunction with pointer arithmetic to read the stack for arguments
and data.


>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?


The minimum number of inspections is one and the max is 1024 times.
If only two bytes of data are copied then the min is still one and
the max is 2048 times.  The minimum numbers can not be improved
because you must inspect it at least once. The maximum numbers could
be improved with a larger number of bytes to copy (e.g. 8 bytes).


>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.


The wait system call calls the process_wait function. process_wait
will get the wait info from the child and wait until the child has
finished running. After the child is finished the parent will return
the return value of the child. If wait is called twice on a child,
the parent will return -1 for the second call to wait. If the child
has already terminated when the parent calls wait, the wait info will
still be available even though the child is dead.


>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.




To avoid causing a page fault or kernel panic when reading and
writing we first check for the validity of the arguments to check
where they are referencing. If the arguments point to kernel space
the user program exits with a status of -1.  We also deny writes to
binary file executable by keeping the files open in the original load
process so they cannot be changed by a user program.  When an error
is detected, such as a reference to kernel space, we call exit. Exit
will then close all files and free allocated resources associated
with the user program.


---- SYNCHRONIZATION ----


>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?


We initialize a semaphore to zero and process_execute waits on the
semaphore before returning. start_process will signal the semaphore
only when is is done loading. The success/failure status is passed
back through the exec_info structure which is what is passed from
process_exec to process_start when starting a new thread.


>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?


When P calls wait(C) before C exits, the parent will wait on a 
emaphore the the child must signal upon exiting. If P calls wait(P)
after C exits, the parent will still have access to the wait_info
from the child. The child is responsible for freeing the resources
for the semaphore. The parent is responsible for freeing the
wait_info resources. If P terminates without waiting, then the
wait_info resources will cause a memory leak. Dr. Neilsen said that
this would be acceptable. We cannot come up with any other special
cases.


---- RATIONALE ----


>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?


We chose our design of implementing access because we found it easier
to use mem_copy instead of using extended assembly code.


>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?


The advantage of our design is that the file descriptor structure can
easily be reference and passed around between functions and contains
all the needed information about a file that is need in the current
implementation.  One disadvantage is that it is more time consuming
to get data out of the structure than it would be to have variables
outside of a structure.


>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?


We did not change the identity mapping.




                           SURVEY QUESTIONS
                           ================


Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.


>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?


>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?


>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?


>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?


>> Any other comments?